#version 460

#define SAMPLES 32
#define BOUNCES 32

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable

#include "imports/ray.comp"
#include "imports/random.comp"

struct Material {
    vec4 base_color;
    vec4 emissive_strength; // can be above 1
    float reflectivity;
    float roughness;
    bool is_glass;
    float ior;
};

struct HitRecord {
    bool did_hit;
    vec3 pos;
    vec3 normal;
    float t;
    Material material;
};

struct Sphere {
    float radius;
    vec3 center;
    Material material;
};

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// todo: look into inline uniform buffers for speed and small data
layout(std430, set = 0, binding = 0) uniform Camera {
    vec2 resolution; // todo: move this to (unsinged) integers
    vec2 uv;
    float focal_len;
    float focus_distance;
    float aperture_radius;
    uint frame;
    vec4 origin;
    mat4 rotation;
} camera;

layout(std430, set = 0, binding = 1) readonly buffer SphereSBO {
    uint count;
    Sphere spheres[];
} sphere_sbo;

layout(set = 0, binding = 2, rgba8) uniform image2D accumulator; 
layout(set = 0, binding = 3) writeonly uniform image2D framebuffer; 

//layout(location = 0) out vec4 out_color;

uint seed;

Ray calculate_ray(vec2 frag_coord) {
    // Scale the virtual camera to make the UV plane coincide with the focus plane
    vec2 focus_plane_uv = camera.uv * (camera.focus_distance / camera.focal_len);

    // The distance between pixels in world-space
    vec2 pixel_delta = focus_plane_uv / camera.resolution;
    pixel_delta *= vec2(1, -1); // Y grows downwards in vulkan, so we have to invert it

    vec3 viewport_origin = vec3(-focus_plane_uv.x/2, focus_plane_uv.y/2, camera.focus_distance) + // Top left of focus plane
                           vec3(pixel_delta/2, 0);  // Center the pixel

    vec3 pixel_coords = viewport_origin + 
                        vec3(pixel_delta * (frag_coord + pixel_offset(seed)), 0); // Jitter for anti-aliasing

    vec3 aperture_offset = vec3(random_disc(seed), 0) * camera.aperture_radius;

    // Vector from origin to pixel, rotated
    vec3 ray_direction = mat3(camera.rotation) * normalize(pixel_coords - aperture_offset);

    // Rotated aperture offset, shifted by camera origin 
    vec3 ray_origin = (mat3(camera.rotation) * aperture_offset) + camera.origin.xyz;

    Ray ray; 
    ray.direction = ray_direction;
    ray.origin = ray_origin;
    return ray;
}

HitRecord hit_sphere(Sphere sphere, Ray ray) {
    /*  line (parametric):
            x = orig_x + dir_x * t
            y = orig_y + dir_y * t   ->   p = orig + dir * t
            z = orig_z + dir_z * t

        sphere formula:
            (x - c_x)^2 + (y - c_y)^2 + (z - c_z)^2 <= radius^2    ->    (p - center).(p - center) <= radius^2

        now we plug the line in the sphere formula and solve for t:
            (orig + dir * t - center).(orig + dir * t - center) <= r^2

            [...]

            a = dir.dir
            b = 2dir.(orig - center)
            c = (center - orig).(center - orig) - radius^2

        referring to the quadratic formula, we can tell whether the ray intersected the sphere by the discriminant:
            hit_sphere = (b^2 - 4ac >= 0)
    */
    vec3 delta = (sphere.center - ray.origin);

    // todo: apply the simpler formula for b multiples of 2
    float a = dot(ray.direction, ray.direction);
    float b = -2 * dot(ray.direction, delta);
    float c = dot(delta, delta) - sphere.radius * sphere.radius;

    float discriminant = b*b - 4*a*c;
    float t = (-b - sqrt(discriminant)) / 2*a;

    HitRecord hit;

    hit.t = t;
    hit.pos = ray_at(ray, t);
    hit.normal = normalize(hit.pos - sphere.center);
    hit.material = sphere.material;

    bool did_not_hit = discriminant < 0;
    bool is_behind = t < 0.0001; // avoid floating point precisions

    // todo: could be solved by avoiding intersections with the same sphere and type twice in a row (eg. cannot enter sphere 2 twice in a row)
    // Done by keeping track of last enter / exit (+2 if enter, -2 if exit), and checking if it's the same.
    // Entering / exiting could be stored in the hit to avoid computing it in the glass shader (and other ones)

    hit.did_hit = !(did_not_hit || is_behind);

    return hit;
}

vec3 background_color(Ray ray) {
    float blend = 0.5 * ray.direction.y + 0.5;
    return mix(vec3(0.6, 0.8, 1.0), vec3(0.2, 0.4, 1.0), blend);
    //return vec3(0);
}

// Schlick approximation of Fresnel on glass
float schlick_reflectance(float cos_angle, float ior) {
    float r0 = (1 - ior) / (1 + ior);
    r0 = r0 * r0;
    return r0 + (1 - r0) * pow((1 - cos_angle), 5);
}

// this does not handle intersecting spheres gracefully, the ratios must be pre-divided for that
void glass_shader(inout Ray ray, HitRecord hit) {
    vec3 normal = hit.normal;
    vec3 dir = ray.direction;
    
    // Check if we're entering or exiting the glass
    float ior_ratio;
    if (dot(normal, dir) > 0) {
        ior_ratio = hit.material.ior / 1.0;
    } else {
        ior_ratio = 1.0 / hit.material.ior;
    }

    float cos_angle = min(dot(-dir, normal), 1.0);
    float sin_angle = sqrt(1 - cos_angle * cos_angle); // todo: faster sin algos?

    bool total_reflection = ior_ratio * sin_angle > 1;
    bool schlick_reflection = pgc_random(seed) < schlick_reflectance(cos_angle, ior_ratio);

    // Check if we should reflect or refract
    vec3 out_dir;
    if (total_reflection || schlick_reflection) {
        out_dir = dir - 2 * dot(dir, normal) * normal;

    } else {
        vec3 refracted_ort = ior_ratio * (dir + cos_angle * normal);

        float ort_len = length(refracted_ort);
        vec3 refracted_par = -sqrt(1 - ort_len * ort_len) * normal;

        out_dir = refracted_ort + refracted_par;
    }

    // apply fuzziness
    out_dir = normalize(out_dir + random_unit_vector(seed) * hit.material.roughness / 2);

    ray.direction = out_dir;
    ray.origin = hit.pos;
}

// cosine-weighted lambertian lighting
void weighted_lambertian_shader(inout Ray ray, HitRecord hit) {
    ray.origin = hit.pos;

    // reflectivity: randomly pick between reflecting and opaque based how reflective the material is
    if (pgc_random(seed) < hit.material.reflectivity) {
        ray.direction = ray.direction - 2 * dot(hit.normal, ray.direction) * hit.normal;
        ray.direction = normalize(ray.direction + random_unit_vector(seed) * hit.material.roughness); // fuzzy reflection
    
    } else {
        ray.direction = normalize(hit.normal + random_unit_vector(seed)); // https://www.iue.tuwien.ac.at/phd/ertl/node100.html
    }
}

vec3 ray_color(Ray ray) {
    /*  The ray only gets light when it hits something emissive.
        The light that will be "received" from the emissive object
         will be tinted multiplicatively by all the surfaces the ray
         hits before reaching the camera.
        If the ray encounters multiple source of light, all of them
         will contribute to the light value of the pixel.

        The result is that we only add light to incoming_light when
         we hit an emissive, and we tint that light to the color that 
         the ray has assumed so far.
    */
    vec3 ray_color = vec3(1);
    vec3 incoming_light = vec3(0);

    for (int bounce = 0; bounce < BOUNCES + 1; bounce++) {
        HitRecord hit;
        hit.t = 1.0 / 0.0; // infinity
        hit.did_hit = false;

        for (int i = 0; i < sphere_sbo.count; i++) {
            HitRecord current_hit = hit_sphere(sphere_sbo.spheres[i], ray);

            if (current_hit.did_hit && current_hit.t < hit.t) {
                hit = current_hit;
            }
        }

        if (hit.did_hit) {
            incoming_light += ray_color * hit.material.emissive_strength.xyz;

            if (hit.material.is_glass) {
                glass_shader(ray, hit);
            } else {
                weighted_lambertian_shader(ray, hit);
            }

            // reduce the strength of light rays grazing the surface as light gets distributed
            ray_color *= hit.material.base_color.xyz;

        } else {
            incoming_light += background_color(ray) * ray_color;
            break;
        }
    }
 
    return incoming_light;
}

vec4 gamma_correction(vec4 color) {
    return sqrt(color);
}

void main() {
    ivec2 coordinates = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);

    if (coordinates.x < size.x && coordinates.y < size.y) {
        //seed = uint(coordinates.x + camera.resolution.x * coordinates.y);
        seed = uint(coordinates.x + camera.resolution.x * coordinates.y + camera.frame * coordinates.y * coordinates.x);

        vec3 color = vec3(0);
        for (int i = 0; i < SAMPLES; i++) {
            Ray ray = calculate_ray(coordinates.xy);

            color += ray_color(ray) / float(SAMPLES);
        }

        vec4 old_pixel = imageLoad(accumulator, coordinates);
        vec4 new_pixel = (old_pixel * (camera.frame) + vec4(color, 1.0)) / (camera.frame + 1);

        imageStore(accumulator, coordinates, new_pixel);
        imageStore(framebuffer, coordinates, gamma_correction(new_pixel));

        //imageStore(framebuffer, coordinates, gamma_correction(vec4(color, 1.0)));
    }
}

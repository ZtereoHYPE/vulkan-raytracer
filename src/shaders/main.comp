#version 460

#define SAMPLES 64
#define BOUNCES 6

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable

#include "imports/ray.comp"
#include "imports/random.comp"

struct Material {
    vec4 base_color;
    vec4 emissive_strength; // can be above 1
    float reflectivity;
    float roughness;
    bool is_glass;
    float ior;
};

struct HitRecord {
    bool did_hit;
    vec3 pos;
    vec3 normal;
    float t;
    Material material;
};

struct Sphere {
    float radius;
    vec3 center;
    Material material;
};

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// todo: look into inline uniform buffers for speed and small data
layout(std430, set = 0, binding = 0) uniform Camera {
    vec2 resolution; // todo: move this to (unsinged) integers
    vec2 uv;
    float focal_len;
    uint frame;
    vec4 origin;
    mat3 rotation;
} camera;

layout(std430, set = 0, binding = 1) readonly buffer SphereSBO {
    uint count;
    Sphere spheres[];
} sphere_sbo;

layout(set = 0, binding = 2, rgba8) uniform image2D accumulator; 
layout(set = 0, binding = 3) writeonly uniform image2D framebuffer; 

//layout(location = 0) out vec4 out_color;

uint seed;

Ray calculate_ray(vec2 frag_coord) {
    /*  We are starting from -uv/2 on each axys, and we need to reach +uv/2.
        Expressed as a formula:
            -uv/2 + pixel_delta * res = +uv/2
            pixel_delta = uv / res

        The Y component is inverted because as the pixels' y axys grows in value
        we want to descend in the 3D space.

        Some of this could be moved to the CPU as a uniform, but is left here
        for now for clarity and because the performance impact is minor.
    */

    float focus_distance = 5.0;
    vec2 defocus_disk = vec2(0.5);

    vec2 pixel_delta = camera.uv/camera.resolution;
    pixel_delta *= vec2(1, -1);

    vec3 pixel_origin = vec3(-camera.uv.x/2, camera.uv.y/2, camera.focal_len) + // the top left is at x=-u but y=v (up is +)
                        camera.origin.xyz +  // to place it correctly in world-space
                        vec3(pixel_delta/2, 0);  // to center the pixel

    // get a random offset for anti-aliasing
    vec2 offset = pixel_offset(seed);
    vec3 pixel_sample = pixel_origin + 
                        vec3(pixel_delta * (frag_coord + offset), 0);

    vec3 direction = normalize(pixel_sample - camera.origin.xyz);

    direction = mat3(camera.rotation) * direction;

    Ray ray;
    ray.direction = direction; // vector from origin to pixel
    ray.origin = camera.origin.xyz;

    return ray;
}

HitRecord hit_sphere(Sphere sphere, Ray ray) {
    /*  line (parametric):
            x = orig_x + dir_x * t
            y = orig_y + dir_y * t   ->   p = orig + dir * t
            z = orig_z + dir_z * t

        sphere formula:
            (x - c_x)^2 + (y - c_y)^2 + (z - c_z)^2 <= radius^2    ->    (p - center).(p - center) <= radius^2

        now we plug the line in the sphere formula and solve for t:
            (orig + dir * t - center).(orig + dir * t - center) <= r^2

            [...]

            a = dir.dir
            b = 2dir.(orig - center)
            c = (center - orig).(center - orig) - radius^2

        referring to the quadratic formula, we can tell whether the ray intersected the sphere by the discriminant:
            hit_sphere = (b^2 - 4ac >= 0)
    */
    vec3 delta = (sphere.center - ray.origin);

    // todo: apply the simpler formula for b multiples of 2
    float a = dot(ray.direction, ray.direction);
    float b = -2 * dot(ray.direction, delta);
    float c = dot(delta, delta) - sphere.radius * sphere.radius;

    float discriminant = b*b - 4*a*c;
    float t = (-b - sqrt(discriminant)) / 2*a;

    HitRecord hit;

    hit.t = t;
    hit.pos = ray_at(ray, t);
    hit.normal = normalize(hit.pos - sphere.center);
    hit.material = sphere.material;

    bool did_not_hit = discriminant < 0;
    bool is_behind = t < 0.0001; // avoid floating point precisions

    hit.did_hit = !(did_not_hit || is_behind);

    return hit;
}

vec3 background_color(Ray ray) {
    float blend = 0.5 * ray.direction.y + 0.5;
    return mix(vec3(0.6, 0.8, 1.0), vec3(0.2, 0.4, 1.0), blend);
    //return vec3(0);
}

// Schlick approximation for Fresnel effect on glass
float schlick_reflectance(float cos_angle, float ior) {
    float r0 = (1 - ior) / (1 + ior);
    r0 = r0 * r0;
    return r0 + (1 - r0) * pow((1 - cos_angle), 5);
}

// todo: this does not handle intersecting spheres gracefully, the ratios must be pre-divided for that
void glass_shader(inout Ray ray, HitRecord hit) {
    vec3 normal = hit.normal;
    vec3 dir = ray.direction;
    
    // Check if we're entering or exiting the glass
    float ior_ratio;
    if (dot(normal, dir) > 0) {
        ior_ratio = hit.material.ior / 1.0;
    } else {
        ior_ratio = 1.0 / hit.material.ior;
    }

    float cos_angle = min(dot(-dir, normal), 1.0);
    float sin_angle = sqrt(1 - cos_angle * cos_angle); // todo: faster sin algos?

    bool total_reflection = ior_ratio * sin_angle > 1;
    bool schlick_reflection = pgc_random(seed) < schlick_reflectance(cos_angle, ior_ratio);

    // Check if we should reflect or refract
    vec3 out_dir;
    if (total_reflection || schlick_reflection) {
        out_dir = dir - 2 * dot(dir, normal) * normal;

    } else {
        vec3 refracted_ort = ior_ratio * (dir + cos_angle * normal);

        float ort_len = length(refracted_ort);
        vec3 refracted_par = -sqrt(1 - ort_len * ort_len) * normal;

        out_dir = refracted_ort + refracted_par;
    }

    // apply fuzziness
    out_dir = normalize(out_dir + random_unit_vector(seed) * hit.material.roughness / 2);

    ray.direction = out_dir;
    ray.origin = hit.pos;
}

// cosine-weighted lambertian lighting
void weighted_lambertian_shader(inout Ray ray, HitRecord hit) {
    ray.origin = hit.pos;

    // reflectivity: randomly pick between reflecting and opaque based how reflective the material is
    if (pgc_random(seed) < hit.material.reflectivity) {
        ray.direction = ray.direction - 2 * dot(hit.normal, ray.direction) * hit.normal;
        ray.direction = normalize(ray.direction + random_unit_vector(seed) * hit.material.roughness); // fuzzy reflection
    
    } else {
        ray.direction = normalize(hit.normal + random_unit_vector(seed)); // https://www.iue.tuwien.ac.at/phd/ertl/node100.html
    }
}

vec3 ray_color(Ray ray) {
    /*  The ray only gets light when it hits something emissive.
        The light that will be "received" from the emissive object
         will be tinted multiplicatively by all the surfaces the ray
         hits before reaching the camera.
        If the ray encounters multiple source of light, all of them
         will contribute to the light value of the pixel.

        The result is that we only add light to incoming_light when
         we hit an emissive, and we tint that light to the color that 
         the ray has assumed so far.
    */
    vec3 ray_color = vec3(1);
    vec3 incoming_light = vec3(0);

    for (int bounce = 0; bounce < BOUNCES + 1; bounce++) {
        HitRecord hit;
        hit.t = 1.0 / 0.0; // infinity
        hit.did_hit = false;

        for (int i = 0; i < sphere_sbo.count; i++) {
            HitRecord current_hit = hit_sphere(sphere_sbo.spheres[i], ray);

            if (current_hit.did_hit && current_hit.t < hit.t) {
                hit = current_hit;
            }
        }

        if (hit.did_hit) {
            incoming_light += ray_color * hit.material.emissive_strength.xyz;

            if (hit.material.is_glass) {
                glass_shader(ray, hit);
            } else {
                weighted_lambertian_shader(ray, hit);
            }

            // reduce the strength of light rays grazing the surface as light gets distributed
            ray_color *= hit.material.base_color.xyz;

        } else {
            incoming_light += background_color(ray) * ray_color;
            break;
        }
    }
 
    return incoming_light;
}

vec4 gamma_correction(vec4 color) {
    return sqrt(color);
}

void main() {
    ivec2 coordinates = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);

    if (coordinates.x < size.x && coordinates.y < size.y) {
        //seed = uint(coordinates.x + camera.resolution.x * coordinates.y);
        seed = uint(coordinates.x + camera.resolution.x * coordinates.y + camera.frame * coordinates.y);

        vec3 color = vec3(0);
        for (int i = 0; i < SAMPLES; i++) {
            Ray ray = calculate_ray(coordinates.xy);

            color += ray_color(ray) / float(SAMPLES);
        }

        vec4 old_pixel = imageLoad(accumulator, coordinates);
        vec4 new_pixel = (old_pixel * (camera.frame) + vec4(color, 1.0)) / (camera.frame + 1);

        imageStore(accumulator, coordinates, new_pixel);
        imageStore(framebuffer, coordinates, gamma_correction(new_pixel));

        //imageStore(framebuffer, coordinates, gamma_correction(vec4(color, 1.0)));
    }
}

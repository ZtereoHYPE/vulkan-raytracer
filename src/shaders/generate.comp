#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable

#include "util/parameters.comp"
#include "util/structures.comp"
#include "util/random.comp"

// todo: experiment with different kernel sizes for different stages
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// todo: look into inline uniform buffers for speed and small data
layout(std430, set = 0, binding = 0) uniform Camera {
    uvec2 resolution;
    vec2 uv;
    float focal_len;
    float focus_distance;
    float aperture_radius;
    uint frame;
    vec4 origin;
    mat4 rotation;
} camera;

layout(std430, set = 0, binding = 1) buffer RayBuffer {
    Ray rays[];
} raybuffer;

Ray generate_ray(vec2 frag_coord, Ray ray) {
    if (camera.frame == 0) {
        ray.light = vec3(0);
        ray.count = 1;
        ray.oob_quadrant = 0;
    } else {
        ray.light *= float(ray.count) / float(ray.count + 1);
        ray.count++; // increment the amount of rays that passed thru this pixel
    }

    // Scale the virtual camera to make the UV plane coincide with the focus plane
    vec2 focus_plane_uv = camera.uv * (camera.focus_distance / camera.focal_len);

    // The distance between pixels in world-space
    vec2 pixel_delta = focus_plane_uv / camera.resolution;
    pixel_delta *= vec2(1, -1); // Y grows downwards in vulkan, so we have to invert it

    vec3 viewport_origin = vec3(-focus_plane_uv.x/2, focus_plane_uv.y/2, camera.focus_distance) + // Top left of focus plane
                           vec3(pixel_delta/2, 0);  // Center the pixel

    uint quadrant = ray.oob_quadrant >> 1;
    vec3 pixel_coords = viewport_origin +
                        vec3(pixel_delta * (frag_coord + pixel_offset(seed, quadrant)), 0); // Jitter for anti-aliasing

    vec3 aperture_offset = vec3(random_disc(seed), 0) * camera.aperture_radius;

    // Vector from origin to pixel, rotated
    vec3 ray_direction = mat3(camera.rotation) * normalize(pixel_coords - aperture_offset);

    // Rotated aperture offset, shifted by camera origin
    vec3 ray_origin = (mat3(camera.rotation) * aperture_offset) + camera.origin.xyz;

    ray.origin = ray_origin;
    ray.oob_quadrant = quadrant << 1; // set the least sig. bit to 0, and then the quadrant
    ray.direction = ray_direction;
    ray.time = pgc_random(seed);
    ray.color = vec3(1); // initialize the ray as white
    ray.bounce = 0;

    return ray;
}

/* Entrypoint */
void main() {
    ivec2 coordinates = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = ivec2(camera.resolution);

    if (coordinates.x < size.x && coordinates.y < size.y) {
        uint idx = coordinates.x + coordinates.y * size.x;
        seed = uint(coordinates.x + camera.resolution.x * coordinates.y + camera.frame * camera.resolution.y * camera.resolution.x);

        // generate the missing / out of bounds rays
        if ((raybuffer.rays[idx].oob_quadrant & 1u) == 1u)
            raybuffer.rays[idx] = generate_ray(coordinates, raybuffer.rays[idx]);
    }
}
